<!DOCTYPE html>
<html>
<head>
	<title>blob-socket</title>
</head>
<body onload="main()">


<div class="container">
	<div class="">
		<canvas id="mycanvas"></canvas>
	</div>
	<div id="identity">
		<span class="color"></span> <span class="name"></span>
		<div class="status"></div>
		<div class="itemlist"></div>
	</div>
	<div id="message">
	</div>
</div>


<style type="text/css">
.container {
	display: flex;
	flex-wrap: wrap;
	width: 600px;
}
	.container > div {
		border: 1px solid black;
		margin: 3px;
		padding: 3px;
	}
#mycanvas {
	/*border: 1px solid black;*/
	image-rendering: pixelated;
}
#identity {
	flex: 1;
}
	#identity .color {
		display: inline-block;
		width: 10px;
		height: 10px;
		border: 1px solid black;
	}
	#identity .name {}
	#identity .status {
		display: flex;
		flex-wrap: wrap;
		margin-top: 10px;
	}
		#identity .status div {
			width: 50%;
		}
	#identity .itemlist {
		display: flex;
		flex-wrap: wrap;
		margin-top: 10px;
	}
	#identity .item {
		border: 1px solid black;
		border-radius: 5px;
		width: 30px;
		height: 30px;
		margin: 2px;
		overflow: hidden;
	}
		#identity .item:hover {
			border: 1px solid red;
		}
#message {
	width: 100%;
	height: 120px;
	overflow-y: hidden;
}
	#message p {
		margin: 0;
		margin-bottom: 0.5em;
	}
</style>


<script type="text/javascript">

function main() {
	console.log('begin');
	server.startConnection();
	draw.mainloop();
}



// server connection management
const server = new function() {
	// vars
	let connection = null;
	let identity = {};
	let state = this.state = [];
	// let map = null;

	// methods
	const onopen = (e) => {
		console.log('websocket connection open');
		// connection.send(JSON.stringify({ type: 'message', text: 'hello' }));
		// this.send({ type: 'state' });  // get initial state
		this.send({ type: 'map' });  // get initial state
		this.send({ type: 'status' });  // get initial player status
		draw.message('Welcome to the game...');
	};
	const onerror = (error) => {
		console.error('websocket connection error', error);
	};
	const onclose = (e) => {
		console.log('websocket connection closed', e);
	};
	const onmessage = (message) => {
		// console.log(message.data);
		const msg = JSON.parse(message.data);
		let index = -1;
		// 
		switch (msg.type) {
		case 'identity':  // my identity
			identity = msg.data;  
			console.log(`recieved identity`, identity);
			draw.setIdentity(identity);
			break;
		case 'message':  // chat message
			// console.log('message:', msg.data);
			draw.message(msg.data);
			break;
		case 'map':
			this.map = msg.data;
			// console.log(msg.data);
			break;
		case 'status':  // full state replacement
			// console.log(msg.data);
			draw.setStats(msg.data);
			break;
		default:  
			console.log('unknown message type', msg);
		}
	};

	this.startConnection = () => {
		const socket = location.protocol === 'https:' ? 'wss' : 'ws';
		connection = new WebSocket(`${socket}://${location.host}`);
		// add event listeners
		connection.onopen = onopen;
		connection.onerror = onerror;
		connection.onclose = onclose;
		connection.onmessage = onmessage;
	};

	this.send = (obj) => {
		connection.send(JSON.stringify(obj));
	};
};



// canvas
const draw = new function() {
	// vars
	const canvas = document.querySelector('#mycanvas');
	const ctx = canvas.getContext('2d');
	const th = 12, tw = 8, fg = 'black', bg = 'white';  // text sizing
	let width = canvas.width = 450;
	let height = canvas.height = 350;

	// drawing
	this.paint = () => {
		ctx.fillStyle = bg;
		ctx.fillRect(0, 0, width, height);
		if (!server.map) return;

		ctx.save();
		ctx.translate(5, 5);
		// draw map data
		ctx.font = `${th}px monospace`;
		ctx.textBaseline = 'top';
		for (let y = 0; y < server.map.height; y++)
		for (let x = 0; x < server.map.width; x++) {
			ctx.fillStyle = fg;
			ctx.fillText(server.map.level[y][x], x*tw, y*th);
		}
		// draw characters
		server.map.mobs.forEach(mob => {
			ctx.fillStyle = bg;
			ctx.fillRect(mob.x*tw, mob.y*th, tw, th);
			switch (mob.type) {
				case '@':  ctx.fillStyle = 'blueviolet';  break;
				case '$':  ctx.fillStyle = 'gold';  break;
				case 'g':  ctx.fillStyle = 'green';  break;
				default:   ctx.fillStyle = 'black';
			}
			ctx.fillText(mob.type, mob.x*tw, mob.y*th);
		});
		ctx.restore();
	};

	// events
	document.addEventListener('keydown', (e) => {
		switch (e.key) {
		case 'w': case 'k': case 'ArrowUp':
			server.send({ type: 'move', dir: 'n' });  break;
		case 's': case 'j': case 'ArrowDown':
			server.send({ type: 'move', dir: 's' });  break;
		case 'd': case 'l': case 'ArrowRight':
			server.send({ type: 'move', dir: 'e' });  break;
		case 'a': case 'h': case 'ArrowLeft':
			server.send({ type: 'move', dir: 'w' });  break;
		case '.':
			server.send({ type: 'move', dir: '.' });  break;
		default:  console.log(e.key);
		}
	});

	// start main loop
	this.mainloop = () => {
		this.paint();
		requestAnimationFrame(this.mainloop);
	};

	this.setIdentity = (identity) => {
		document.querySelector('#identity .color').style.backgroundColor = identity.color;
		document.querySelector('#identity .name').innerHTML = identity.id;
	};
	this.setStats = (status) => {
		console.log(status);
		// player stats
		const st = document.querySelector('#identity .status');
		st.innerHTML = '';
		Object.keys(status.stats).forEach(key => st.innerHTML += `<div>${key}:</div> <div>${status.stats[key]}</div>`);
		// inventory
		const itl = document.querySelector('#identity .itemlist');
		itl.innerHTML = '';
		status.inventory.forEach(it => 
			itl.innerHTML += `<div class="item" item-id="${it.id}">${it.name}</div>`);
		itl.querySelectorAll('.item').forEach(div => div.onclick = () => {
			const id = parseInt(div.getAttribute('item-id'));
			server.send({ type: 'item', id: id });
		});
	};

	this.message = (message) => {
		const msg = document.querySelector('#message');
		// msg.innerHTML = `<div>${message}</div>` + msg.innerHTML;
		msg.innerHTML += `<div>${message}</div>`;
		msg.scrollTop = msg.scrollHeight;
	};
};
	
</script>


</body>
</html>